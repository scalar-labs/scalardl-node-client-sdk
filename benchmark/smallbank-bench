#!/usr/bin/env node
/* eslint-disable require-jsdoc */

const {ClientService} = require('../');
const fs = require('fs');

(async () => {
  const [
    properties,
    numberOfAccount,
    numberOfThread,
    duration,
    rampUpTime,
    operations,
  ] = parseArgv();
  const clientService = new ClientService(properties);
  const accounts = Array.from(Array(numberOfAccount).keys());
  const durationMillis = duration * 1000;
  const rampUpTimeMillis = rampUpTime * 1000;

  const errorCount = new Uint32Array(new SharedArrayBuffer(1024));
  const counter = new Uint32Array(new SharedArrayBuffer(1024));
  const totalCounter = new BigUint64Array(new SharedArrayBuffer(1024));
  const latencyTotal = new BigUint64Array(new SharedArrayBuffer(1024));
  let isRunning = true;

  const start = Date.now();
  let from = start;
  for (let i = 0; i < numberOfThread; i++) {
    (async () => {
      while (isRunning) {
        const [operation, argument] = createExecution(operations, accounts);
        try {
          const eachStart = Date.now();
          await clientService.executeContract(operation, argument);
          const eachEnd = Date.now();
          Atomics.add(counter, 0, 1);

          if (Date.now() >= start + rampUpTimeMillis) {
            Atomics.add(totalCounter, 0, BigInt(1));
            Atomics.add(latencyTotal, 0, BigInt(eachEnd - eachStart));
          }
        } catch (e) {
          Atomics.add(errorCount, 0, 1);
        }
      }
    })();
  }
  const end = start + durationMillis + rampUpTimeMillis;

  while (true) {
    const to = Date.now();
    if (to >= end) {
      isRunning = false;
      break;
    }
    console.log(`${(Atomics.load(counter, 0) * 1000) / (to - from)} tps`);
    Atomics.store(counter, 0, 0);
    from = Date.now();
    await sleep(1000);
  }

  const tps =
    (Atomics.load(totalCounter, 0) * BigInt(1000)) / BigInt(durationMillis);
  const averageLatency =
    Atomics.load(latencyTotal, 0) / Atomics.load(totalCounter, 0);

  console.log(`TPS: ${tps}`);
  console.log(`Average-Latency(ms): ${averageLatency}`);
  console.log(`Error-Counts: ${errorCount[0]}`);
})();

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function createExecution(operations, accounts) {
  const operation = operations[getRandomInt(operations.length)];
  const account1 = accounts[getRandomInt(accounts.length)];
  let account2 = accounts[getRandomInt(accounts.length)];
  if (account2 === account1) {
    account2 = (account2 + 1) % accounts.length;
  }
  const amount = getRandomInt(100) + 1;
  let argument = {};

  switch (operation) {
    case 'transact_savings':
    case 'deposit_checking':
    case 'write_check':
      argument = {
        customer_id: account1,
        amount: amount,
      };
      break;

    case 'send_payment':
      argument = {
        source_customer_id: account1,
        dest_customer_id: account2,
        amount: amount,
      };
      break;

    case 'amalgamate':
      argument = {
        source_customer_id: account1,
        dest_customer_id: account2,
      };
      break;
  }

  return [operation, argument];
}

function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

function parseArgv() {
  let properties = JSON.parse(
      fs.readFileSync('client.properties.json', 'utf8'),
  );
  let numberOfAccount = 10000;
  let numberOfThread = 1;
  let duration = 200;
  let rampUpTime = 60;
  let operations = [
    'transact_savings',
    'deposit_checking',
    'send_payment',
    'write_check',
    'amalgamate',
  ];

  const argv = process.argv.slice(2);

  for (let i = 0; i < argv.length; i++) {
    switch (argv[i]) {
      case '--properties':
      case '--config':
        if (argv[i + 1] && fs.existsSync(argv[i + 1])) {
          properties = JSON.parse(fs.readFileSync(argv[i + 1], 'utf-8'));
          i++;
        } else {
          usage();
          process.exit(1);
        }
        break;

      case '--num-accounts':
        if (argv[i + 1] && !isNaN(argv[i + 1]) && parseInt(argv[i + 1]) > 0) {
          numberOfAccount = parseInt(argv[i + 1]);
          i++;
        } else {
          usage();
          process.exit(1);
        }
        break;

      case '--num-threads':
        if (argv[i + 1] && !isNaN(argv[i + 1]) && parseInt(argv[i + 1]) > 0) {
          numberOfThread = parseInt(argv[i + 1]);
          i++;
        } else {
          usage();
          process.exit(1);
        }
        break;

      case '--duration':
        if (argv[i + 1] && !isNaN(argv[i + 1]) && parseInt(argv[i + 1]) > 0) {
          duration = parseInt(argv[i + 1]);
          i++;
        } else {
          usage();
          process.exit(1);
        }
        break;

      case '--ramp-up-time':
        if (argv[i + 1] && !isNaN(argv[i + 1]) && parseInt(argv[i + 1]) > 0) {
          rampUpTime = parseInt(argv[i + 1]);
          i++;
        } else {
          usage();
          process.exit(1);
        }
        break;

      case '--operation':
        if (argv[i + 1] && argv[i + 1].split(',').length > 0) {
          operations = argv[i + 1].split(',');
          i++;
        } else {
          usage();
          process.exit(1);
        }
        break;

      case '-h':
      case '--help':
        usage();
        process.exit(0);
    }
  }

  return [
    properties,
    numberOfAccount,
    numberOfThread,
    duration,
    rampUpTime,
    operations,
  ];
}

function usage() {
  const path = require('path');
  console.log(
      'Usage: ' +
      `${path.basename(process.argv[1])} ` +
      '[--properties PROPERTIES_FILE, --config PROPERTIES_FILE] ' +
      '[--num-accounts NUM_ACCOUNTS] ' +
      '[--num-threads NUM_THREADS] ' +
      '[--duration DURATION] ' +
      '[--ramp-up-time RAMP_UP_TIME] ' +
      '[--operation OPERATION] ' +
      '[-h, --help]',
  );

  console.log(
      '\t--properties PROPERTIES_FILE, --config PROPERTIES_FILE\n' +
      '\t\tA configuration file in properties format.\n' +
      '\t--num-accounts NUM_ACCOUNTS\n' +
      '\t\tThe number of target accounts.\n' +
      '\t--num-threads NUM_THREADS\n' +
      '\t\tThe number of threads to run.\n' +
      '\t--duration DURATION\n' +
      '\t\tThe duration of benchmark in seconds\n' +
      '\t--ramp-up-time RAMP_UP_TIME\n' +
      '\t\tThe ramp up time in seconds.\n' +
      '\t--operation OPERATION\n' +
      '\t\ttransact_savings, ' +
      'deposit_checking, send_payment, write_check, amalgamate',
  );
}
